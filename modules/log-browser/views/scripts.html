<script type="module">
import { apiFetch } from '/public/js/utils.js';

let currentCategory = null;
let currentLogPath = null;
let logFiles = [];

// Initialisierung
document.addEventListener('DOMContentLoaded', () => {
    loadCategories();
    setupEventListeners();
});

function setupEventListeners() {
    // Filter-Ereignisse
    document.getElementById('file-search').addEventListener('input', filterFiles);
    document.getElementById('type-filter').addEventListener('change', filterFiles);
    document.getElementById('content-filter').addEventListener('input', debounce(reloadLogContent, 300));
    document.getElementById('line-count').addEventListener('change', reloadLogContent);
    document.getElementById('format').addEventListener('change', reloadLogContent);
    
    // Buttons
    document.getElementById('refresh-btn').addEventListener('click', reloadLogContent);
    document.getElementById('analyze-btn').addEventListener('click', analyzeCurrentLog);
}

// Kategorien laden und anzeigen
async function loadCategories() {
    try {
        const { categories } = await apiFetch('/api/log-browser/categories');
        const container = document.getElementById('categories-list');
        container.innerHTML = '';

        categories.forEach(category => {
            const item = document.createElement('div');
            item.className = 'category-item';
            item.textContent = category.name;
            item.dataset.id = category.id;

            item.addEventListener('click', () => {
                document.querySelectorAll('.category-item').forEach(el => el.classList.remove('active'));
                item.classList.add('active');
                currentCategory = category.id;
                loadFiles(category.id);
            });

            container.appendChild(item);
        });
    } catch (error) {
        console.error('Fehler beim Laden der Kategorien:', error);
    }
}

// Log-Dateien einer Kategorie laden
async function loadFiles(categoryId) {
    try {
        const { files } = await apiFetch(`/api/log-browser/files/${categoryId}`);
        logFiles = files;
        filterFiles();
    } catch (error) {
        console.error('Fehler beim Laden der Dateien:', error);
        document.getElementById('files-list').innerHTML = 
            `<tr><td colspan="4">Fehler beim Laden der Dateien: ${error.message}</tr>`;
    }
}

// Dateien filtern und anzeigen
function filterFiles() {
    const searchTerm = document.getElementById('file-search').value.toLowerCase();
    const typeFilter = document.getElementById('type-filter').value;
    
    const filteredFiles = logFiles.filter(file => {
        const matchesSearch = file.name.toLowerCase().includes(searchTerm);
        const matchesType = !typeFilter || file.type === typeFilter;
        return matchesSearch && matchesType;
    });

    renderFiles(filteredFiles);
}

// Dateien in der Tabelle anzeigen
function renderFiles(files) {
    const tbody = document.getElementById('files-list');
    if (files.length === 0) {
        tbody.innerHTML = '<tr><td colspan="4">Keine Dateien gefunden</tr>';
        return;
    }

    tbody.innerHTML = files.map(file => `
        <tr class="log-file-row" data-path="${file.path}">
            <td>
                ${file.name}<br>
                <small>${file.path}</small>
            <td><u2-bytes>${file.size}</u2-bytes>
            <td><u2-time second datetime="${file.modified}" type="relative">${file.modified}</u2-time>
        </tr>
    `).join('');

    // Klick-Event für Zeilen
    tbody.querySelectorAll('.log-file-row').forEach(row => {
        row.addEventListener('click', () => {
            tbody.querySelectorAll('.log-file-row').forEach(r => r.classList.remove('active'));
            row.classList.add('active');
            currentLogPath = row.dataset.path;
            loadLogContent();
        });
    });
}

// Log-Inhalt laden
async function loadLogContent() {
    if (!currentLogPath) return;

    const logContent = document.getElementById('log-content');
    logContent.textContent = 'Lade Inhalt...';

    try {
        const filter = document.getElementById('content-filter').value;
        const lines = document.getElementById('line-count').value;
        const format = document.getElementById('format').value;

        const { content, entries, error } = await apiFetch('/api/log-browser/content', {
            post: {
                path: currentLogPath,
                filter,
                lines: parseInt(lines),
                format: format === 'auto' ? undefined : format
            }
        });

        if (error) {
            logContent.innerHTML = `<div class="error">${error}</div>`;
            return;
        }

        logContent.innerHTML = formatLogContent(content, entries);
        logContent.scrollTop = 0;
    } catch (error) {
        logContent.innerHTML = `<div class="error">Fehler beim Laden: ${error.message}</div>`;
    }
}

// Log-Inhalt formatieren mit Syntax-Highlighting und verbesserter Darstellung
function formatLogContent(content, entries) {
    if (!entries) return content;

    return entries.map(entry => {
        const level = entry.level.toLowerCase();
        let cssClass = 'info-level';
        if (level.includes('error')) cssClass = 'error-level';
        else if (level.includes('warn')) cssClass = 'warning-level';
        else if (level.includes('debug')) cssClass = 'debug-level';

        const contextHtml = entry.context && Object.keys(entry.context).length > 0 
            ? `<div class="log-context">
                ${Object.entries(entry.context)
                    .map(([key, value]) => `<span class="context-item"><strong>${key}:</strong> ${value}</span>`)
                    .join(' • ')}
               </div>`
            : '';

        return `
            <div class="log-entry ${cssClass}">
                <div class="log-header">
                    <div class="log-meta">
                        ${entry.date ? `
                            <u2-time second datetime="${entry.date}" type=relative>
                                ${entry.date}
                            </u2-time>
                        ` : '<span class="no-date">Kein Datum</span>'}
                        <small class="u2-badge status-${level}">${entry.level}</small>
                    </div>
                    ${contextHtml}
                </div>
                <div class="log-message">${entry.message}</div>
            </div>`;
    }).join('');
}

// Log-Datei analysieren
async function analyzeCurrentLog() {
    if (!currentLogPath) {
        alert('Bitte wähle erst eine Log-Datei aus');
        return;
    }

    try {
        const analysis = await apiFetch('/api/log-browser/analyze', {
            post: { path: currentLogPath }
        });

        // Statistik anzeigen
        document.getElementById('log-stats').innerHTML = `
            <p>Anzahl Einträge: ${analysis.totalEntries}</p>
            <p>Level-Verteilung:</p>
            <ul>
                ${Object.entries(analysis.levels)
                    .map(([level, count]) => `<li>${level}: ${count}</li>`)
                    .join('')}
            </ul>
        `;

        // Level-Verteilung visualisieren
        const levelDist = document.getElementById('level-distribution');
        levelDist.innerHTML = Object.entries(analysis.levels)
            .map(([level, count]) => `
                <div class="level-bar">
                    <div class="level-label">${level}</div>
                    <div class="level-value" style="width: ${(count / analysis.totalEntries * 100)}%">
                        ${count}
                    </div>
                </div>
            `).join('');

        // Zeitverteilung visualisieren
        const timeDist = document.getElementById('time-distribution');
        timeDist.innerHTML = Object.entries(analysis.timeDistribution)
            .map(([hour, count]) => `
                <div class="time-bar">
                    <div class="time-label">${hour}:00</div>
                    <div class="time-value" style="height: ${(count / analysis.totalEntries * 100)}%">
                        ${count}
                    </div>
                </div>
            `).join('');

        document.getElementById('analysis-modal').showModal();
    } catch (error) {
        alert('Fehler bei der Analyse: ' + error.message);
    }
}

// Hilfsfunktionen
function debounce(func, wait) {
    let timeout;
    return function executedFunction(...args) {
        const later = () => {
            clearTimeout(timeout);
            func(...args);
        };
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
    };
}

function reloadLogContent() {
    if (currentLogPath) loadLogContent();
}
</script>

<style>
.level-bar, .time-bar {
    display: flex;
    align-items: center;
    margin-bottom: 4px;
}

.level-label, .time-label {
    width: 80px;
    font-size: 0.8em;
}

.level-value, .time-value {
    background: #2196f3;
    color: white;
    padding: 2px 8px;
    border-radius: 2px;
    transition: width 0.3s;
    text-align: right;
    font-size: 0.8em;
}

.time-distribution {
    display: flex;
    align-items: flex-end;
    height: 150px;
    gap: 2px;
}

.time-bar {
    flex: 1;
    display: flex;
    flex-direction: column;
    align-items: center;
    height: 100%;
}

.time-value {
    width: 100%;
    background: #4caf50;
}

.log-file-row {
    cursor: pointer;
}

.log-file-row:hover {
    background-color: #f5f5f5;
}

.log-file-row.active {
    background-color: #e3f2fd;
}

.log-entry {
    margin: 0.5em 0;
    padding: 0.5em;
    border-radius: 4px;
    border-left: 4px solid transparent;
}

.log-entry.error-level { border-left-color: #d32f2f; background: rgba(211, 47, 47, 0.05); }
.log-entry.warning-level { border-left-color: #f57c00; background: rgba(245, 124, 0, 0.05); }
.log-entry.info-level { border-left-color: #0288d1; background: rgba(2, 136, 209, 0.05); }
.log-entry.debug-level { border-left-color: #388e3c; background: rgba(56, 142, 60, 0.05); }

.log-header {
    margin-bottom: 0.3em;
}

.log-meta {
    font-size: 0.85em;
    display: flex;
    align-items: center;
    gap: 0.5em;
}

.log-context {
    font-size: 0.8em;
    margin-top: 0.2em;
    color: #666;
}

.context-item {
    display: inline-block;
    margin-right: 1em;
}

.context-item strong {
    color: #444;
}

.log-message {
    font-family: monospace;
    white-space: pre-wrap;
    word-break: break-word;
}

.no-date {
    color: #999;
    font-style: italic;
}

u2-time {
    color: #666;
}
</style>